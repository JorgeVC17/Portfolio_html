[["index.html", "Portfolio Introduction", " Portfolio Hello there! I’m Jorge Vargas Centeno and this is my portfolio where you can explore and visualize my multiple projects in R, Python and multiple machine learning techniques. Introduction Since I was a kid, I knew that I was a curious person. I always wanted to learn something new, something interesting, something that really makes me happy. For all this reasons I’ve have various experiences and works where I develop multiples skills and knowledge. I am currently studying Life Sciences: Medische en Biologische Onderzoek at Hogeschool Utrecht, during which I’ve found a blend of personal interests and professional goals of mine. I enjoy learning about how the human system works and different research methods and articles, as well as the practice lessons where I learned various techniques and skills that are relevant in the medical research world. At the start of the current school year, I started the minor “Big Data &amp; Design”. During this minor I learned to programming in python to communicate statistical information over the impact of data in our world. I also learned various Machine Learning techniques such as Computer Vision, Classification algorithms and Generative AI and I develop multiple design skills in programs such as Figma where I learned the basic concepts of UI/UX design and the importance of design behind the development of applications and start-up ideas. After this minor I choose to specialise in Data Science, where I learn to programming in R and Bash to communicate statistical information about medical and scientific researches. During this specialization I developed skills such as Next Generation Sequencing techniques, RNA-sequencing, and metagenomics. Besides my academic journey I’ve made some experience as Volunteer Social Worker by The Mall Jongerenwerk Gorinchem, where I mastered skills such as communication and presentation of obtain results to parents and schools, organization of multiple activities, projects and events. I also have learned how to solve complex problems and situations. I also learn how to react to complex emotional situations. "],["what-are-my-plans-for-the-future.html", "What are my plans for the future?", " What are my plans for the future? In the past year, I have found that one of my many passions is programming and I mean programming with focus in the world of data analysis and machine learning techniques. For this reason I would like to keep developing and improving this skills. I see myself in the future working as freelancer analyzing and communicating data en proposing how to implement different AI-models and techniques in the projects of various companies and enterprises.This companies/enterprises can be related to the Life Sciences area/sector or not. Because I think that my current skills and the future skills that want to develop can be applied to multiple areas or sector. I think in this way, because in the last years I have applied this knowledge in the Social sector where I impart multiple workshops to the youth of how to code in python to use various machine learning techniques for the projects. To reach this goal I want to try in every free time that I have to learn a new machine learning technique or library that helps me to communicate easier and better the data that I have analyzed. For this reason my plan for my free schedule is to learn another machine-learning technique. The machine-learning technique that I want to learn is “Computer Vision”. I think that this machine-learning technique will be incredibly valuable in the future and for this reason I want to train an algorithm to identify rats. If I succeed the next step will be train an algorithm to identify if a rat have stress or if it’s in an optimal state. "],["rna-sequencing.html", "RNA Sequencing Data Structure: Onderdeel 1: Onderdeel 2: Onderdeel 3: Onderdeel 4:", " RNA Sequencing Data Structure: The data structure of this project is the next one: Datatree of the “RNA-sequencing” projects Note 1: The data need it for this project is property of “Hogeschool Utrecht, thus due copyright and privacy laws I’m not avaible to share most of data used for this experiment.But you can still read the documentation and code of this experiment. Note 2: The language used in this is project is Dutch Onderdeel 1: Introductie Autoren: Carissa Eijking en Jorge Vargas Centeno Hersenziekten, zoals bijvoorbeeld de ziekte van Parkinson, worden veroorzaakt door verstoorde functie van hersencellen. De exacte moleculaire mechanismen zijn vaak onbekend, waardoor het heel waardevol zou zijn om deze cellen in een laboratorium te kunnen onderzoeken. Echter is het niet mogelijk om het hersenweefsel van een levend persoon te bestuderen. Als oplossing kunnen hersencellen gemaakt worden uit fibroblasten. Fibroblasten kunnen worden omgezet naar geïnduceerde pluripotente stamcellen (iPSCs) en vervolgens kunnen deze differentiëren naar hersencellen. Dit kost echter veel tijd. Hierdoor is een alternatieve methode het direct omzetten van fibroblasten naar hersencellen door overexpressie van bepaalde transcriptiefactoren. Dit heet transdifferentiatie. Voor deze opdracht maken we gebruik van gepubliceerde data waarin fibroblasten van een proefpersoon werden behandeld met een controle transcriptiefactor (BCLXL) of de transcriptiefactor (ONECUT2). Van ONECUT2 wordt vermoed dat het fibroblasten naar hersencellen kan omzetten. Er werden verschillende RNA-seq datasets voor elke fibroblast gegenereerd, waarbij elke conditie (celtype) in duplo werd gemeten. Experiment Onderzoeksvraag Wat zijn de verschillen in genexpressie tussen BCLXL behandelde fibroblasten en ONECUT2 behandelde fibroblasten? Informatie over het experiment Cel type: Fibroblasten uit de huid van de proef persoon Genome: Homo sapiens (h38) DNA type: Paired end sequencing DNA Sequencing machine: Illumina NextSeq 500 Samples Resultaten van de fastQC html rapporten (#fig:fastQC html rapporten)Fig. 1: Kwaliteit distributie: links is de per base quality zichtbaar van de forward read en rechts van de Reverse read. De Phred scores gaan van 0 tot 36. Conclusie: De forward en reverse reads bevatten gemiddelde Phred scores, blauwe lijn, van &gt;30 en geen sequences van slechte kwaliteit. Dit indiceert dat de kans waarop een verkeerde nucleotide is weergegeven kleiner is dan 99,9%. De reads zijn dus van voldoende kwaliteit en een alignment kan worden uitgevoerd. Onderdeel 2: Count table De alignment van de dataset met het referentiegenoom is al uitgevoerd. De ontstane bam-bestanden geven voor alle RNA-seq fragmenten de genomische locatie in het referentie genoom weer en bevatten de alignment scores en kunnen hierdoor gebruikt worden om te bepalen welke genen tot expressie zijn gebracht. Door gebruik van de bam-bestanden, willen we tellen voor elk gen hoeveel fragmenten uitlijnen tegenover dat gen in het BCLXL behandelde monster of ONECUT behandelde monster. Dit is belangrijk voor de differentiële expressieanalyse, aangezien dit zal dienen als input. We kunnen deze “count” tabel maken m.b.v het Rsubread-pakket: featureCounts(). Count tabel # Maak een object met de directory van bam bestanden bam_dir &lt;- &quot;/home/daur2/rnaseq/rnaseq_onecut/bam&quot; # Maak een object met output dir voor count tables counts_dir &lt;- &quot;projects/rna_sequencing/data/count_tables&quot; # Create vector with names of bam files bam_files &lt;- list.files(bam_dir, pattern = &quot;SRR7866[6,7]{1}[09]{1}[034]{1}\\\\.bam$&quot;, full.names = TRUE) # Count the reads per gene using the in-built NCBI RefSeq annotations read_counts &lt;- featureCounts( files = bam_files, annot.inbuilt = &quot;hg38&quot;, useMetaFeatures = TRUE, strandSpecific = 0, isPairedEnd = TRUE, countReadPairs = TRUE, nthreads = 10 ) Nu dat de count tabel is gemaakt, kan de statistieke analyse worden uitgevoerd. Count tabel (statistieken) #Load read counts counts &lt;- readRDS(&quot;projects/rna_sequencing/count_tables/read_counts_OC2.rds&quot;) #Inspect count table str(counts) #Pakt de statieken van de lijst af. counts_stats &lt;- counts$stat #Verwijderd status kolom ##convert first column to rownames rownames(counts_stats) &lt;- counts_stats$Status ##Zet de status kolom naar NULL counts_stats$Status &lt;- NULL #Tidy maken counts_stats_t &lt;- counts_stats %&gt;% t %&gt;% as.tibble() %&gt;% mutate(bamfile=colnames(counts_stats), totaal=colSums(counts_stats), perc_assign_frags=Assigned/totaal*100) #Plot de percentage assign reads counts_stats_t %&gt;% ggplot(aes(x=bamfile, y=perc_assign_frags, group=bamfile, fill=bamfile)) + geom_col() + geom_hline(yintercept = 60, linetype= &quot;dashed&quot;) + geom_hline(yintercept = 40, linetype = &quot;dashed&quot;) + theme_classic() + theme(axis.text.x = element_text(angle = 90)) + #Zet de naam van de het bestand in verticaal scale_y_continuous(breaks = seq(0, max(100), by = 10)) + #Veranderd de stappen van de y-axis coord_cartesian(ylim=c(0,100))+ labs( title=&quot;Fig 2: Percentage toegewezen fragmenten per sample&quot;, x=&quot;Sample&quot;, y=&quot;Percentage toegewezen fragmenten per sample.&quot; ) Conclusie: Op basis van de resultaten van figuur 2 kunnen we concluderen dat 40% - 60% van de fragmenten aan een gen kunnen worden toegewezen. Deze percentages zijn vrij laag. Dit kan een impact hebben op de komende analyses van dit experiment, omdat het lage aantal “toegewezen” fragmenten aangeeft dat een aantal fragmenten zich op andere locaties hebben gebonden of niet zijn gebonden. Dit kan leiden tot een onjuiste interpretatie van het verschil in genexpressie tussen de behandelde fibroblasten of verkeerde interpretatie van upgereguleerde of downgereguleerde genen. Discussie: Een mogelijk reden voor deze lage percentages gebonden fragmenten, is een mogelijke contaminatie van DNA in de monsters tijdens de uitvoering van dit experiment. Dit zal zorgen dat een redelijke aantal RNA fragmenten aan dit contaminatie DNA binden, waardoor ze niet correct kunnen worden geïnterpreteerd als toegewezen fragmenten. Ook kan het zijn dat dit DNA juist gezien wordt als RNA dat zich niet kon uitlijnen tegenover het referentie genoom. Dit verlaagt dan ook het percentage toegewezen fragmenten. DESeq2 analyse Omzetten van de “count tabel” naar een DESeq object Voordat de functies in het DESeq2-pakket gebruikt kunnen worden, moet eerst de “count tabel” omgezet worden naar een DESeq-object. Hiervoor zijn de volgende “inputs” nodig: Een matrix met het aantal fragmenten voor elk gen per monster (the count table). Een dataframe waarin voor elk monster in de matrix (kolommen in de matrix) de experimentele details worden gedetailleerd. Een formule die de experimentele opzet gedetailleerd.(Dus welke monsters moeten worden vergeleken om het verschil in genexpressieniveaus te vinden). 1. “Count matrix” verkrijgen # Count matrix count_matrix &lt;- counts$counts 2. Creëren van een datafram met metadata #Import sample data metadata &lt;- read_csv(&quot;/home/daur2/rnaseq/rnaseq_onecut/onecut_sampledata_OC2.csv&quot;) #Omzet de metadata naar een dataframe metadata &lt;- as.data.frame(metadata) #Voeg rijnamen naar de metadata dataframe rownames(metadata) &lt;- paste0(metadata$Run, &quot;.bam&quot;) #Check de eerste lijnen van de metadata object head(metadata) #Controleert dat de kolommen van de count matrix en rijen van de metadata dezelfde namen hebben. colnames(count_matrix) == rownames(metadata) 3. Creëren van een formule met experimentele opzet #Creëert een kolom met de test conditie metadata &lt;- metadata %&gt;% mutate(treatment = str_replace(Cell_type, &quot;Skin derived fibroblast overexpressing Bclxl&quot;, &quot;BCLXL&quot;) %&gt;% str_replace(&quot;2 days after induction of OC2 in skin derived fibroblasts&quot;, &quot;ONECUT2&quot;)) metadata$treatment &lt;- metadata$treatment %&gt;% factor(levels = c(&quot;BCLXL&quot;, &quot;ONECUT2&quot;)) Alle “inputs” zijn gegenereerd, waardoor het DESeqDataset object gemaakt kan worden. Maak een DESeq object #Creëert een DESeqDataset object dds &lt;- DESeqDataSetFromMatrix( countData = count_matrix, colData = metadata, design = ~ treatment ) RNASeq data normaliseren Voordat de kwaliteit van RNA-sequencing data gecontroleerd kan worden, moet de data genormaliseerd worden. Normalisatie van data is belangrijk, omdat het helpt om de variabiliteit in de data te corrigeren en ervoor te zorgen dat de analyses juist zijn. Het maakt het ook makkelijker om te zien welke genen upgereguleerd of downgereguleerd worden na de verschillende behandelingen, in dit geval: “Fibroblasten behandeld met BCLXL” en “Fibroblasten behandeld met ONECUT2” dds_normalized &lt;- rlog(dds) Onderdeel 3: Kwaliteitscontrole Principal component analysis Het aantal genen in deze dataset is 28.395. Dit is vrij lastig weer te geven en te analyseren. Hierdoor wordt principal component analysis (PCA) uitgevoerd. Het is een methode die het aantal variabelen, in dit geval de genen, te verkleinen door middel van een aantal lineaire combinaties. De grootste spreiding genen wordt dan gevangen in een eerste variabele, principal component 1 (PC1). Dit gaat dan door tot alle genen zijn samengevat. Zo kan de scheiding van de genen gebaseerd op genexpressie duidelijker weergegeven worden. #Uitvoert PCA methode met de genormaliseerd data pca &lt;- dds_normalized %&gt;% assay() %&gt;% t() %&gt;% prcomp() De PCA analyse geeft in dit geval 4 nieuwe variabelen. Om te bekijken hoeveel van data elke PC representeert wordt de summary() function gebruikt. pca_summary &lt;- summary(pca)$importance pca_summary PC1 representeert 94.6% van de variatie. PC2 representeert 3,1% van de variatie. PC3 representeert 2.3% van de variatie. PC4 representeert afgerond 0% van de variatie. Hypothese Er wordt verwacht dat er een verschil is in genexpressie tussen de fibroblasten behandeld met BCLXL en de fibroblasten behandeld met ONECUT2. Dit zal zorgen voor een grotere afstand op de x-as tussen deze genen. Aangezien de gebruikte cellijn voor elke behandeling hetzelfde is, zullen er geen verschillen zijn genexpressie afkomstig door verschillende cellijnen. De afstand op de y-as zal dan klein zijn. Plot de principal components #Maak een data frame met metadata en PCA waardes pca_plotting &lt;- cbind(metadata, pca$x) # Verkrijg de percentages van PCs PC1_var &lt;- round(pca_summary[&quot;Proportion of Variance&quot;, &quot;PC1&quot;]*100, digits = 1) PC2_var &lt;- round(pca_summary[&quot;Proportion of Variance&quot;, &quot;PC2&quot;]*100, digits = 1) PC3_var &lt;- round(pca_summary[&quot;Proportion of Variance&quot;, &quot;PC3&quot;]*100, digits = 1) PC4_var &lt;- round(pca_summary[&quot;Proportion of Variance&quot;, &quot;PC4&quot;]*100, digits = 1) # Voeg de percentages toe aan de data frame percentages &lt;- c(PC1_var, PC2_var, PC3_var, PC4_var) df &lt;- tibble(PC = c(&quot;PC1&quot;,&quot;PC2&quot;,&quot;PC3&quot;,&quot;PC4&quot;), Percentage=percentages) pca_plotting2 &lt;- merge(pca_plotting, df) # Plot de PC variabelen in een staafdiagram ggplot(pca_plotting2) + geom_col(aes(x=PC, y=Percentage, fill = PC)) + ggtitle(&quot;Fig 3: PC percentages van de PCA voor \\n fibroblasten transdifferentiatie onderzoek&quot;) + xlab(&quot;PC&quot;) + ylab(&quot;Proportie van Variatie (%)&quot;) + theme_bw() #Plot PC1 vs PC2 ggplot(pca_plotting) + geom_point(aes(x=PC1, y=PC2, color = treatment), size = 5) + ggtitle(&quot;Fig 4: PCA plot voor fibroblasten transdifferentiatie onderzoek&quot;) + xlab(paste0(&quot;PC1 (&quot;, PC1_var, &quot;%)&quot;)) + ylab(paste0(&quot;PC2 (&quot;, PC2_var, &quot;%)&quot;)) + theme_bw() Conclusie: Op basis van de resultaten van figuur 3 is te zien dat PC1 90% van de variatie weergeeft van de RNA-sequencing data. Op basis van de resultaten van figuur 4 kan geconclueerd worden dat er een groot verschil is in de genexpressie tussen de “Fibroblasten behandeld met BCLXL” en “Fibroblasten behandeld met ONECUT2”. Hierdoor is er een grote afstand zichtbaar tussen de fibroblasten op de x-as. Dit komt overeen met de hypothese. Er wordt ook gezien dat er een groot verschil in de genexpressie tussen de fibroblasten samples is. Dit is vreemd, aangezien de behandelingen in duplo uitgevoerd zijn met de exact zelfde cellijnen en behandelingen. Hoogst waarschijnlijk is er iets mis gegaan tijdens de behandelingen van de duplo meting, zoals contaminatie. Dit kan ook het lage percentage verklaren van het aantal toegewezen fragmenten. Differential gene expression analysis Er moet uiteindelijk bekeken worden wat het verschil is in genexpressie tussen “Fibroblasten behandeld met BCLXL” en “Fibroblasten behandeld met ONECUT2”. Hiervoor wordt gebruik gemaakt van een “Differential Gene Expression (DGE)” analyse. In een DGE analyse wordt gezocht naar een set genen met een ander expressie profiel ten opzichte van een andere conditie. Deze genen zijn dan “differentially expressed (DE)”. Hiertoe wordt gekeken naar significantie en dus p-waarden. Een p-waarde geeft weer of er een significant verschil aanwezig is tussen twee condities. In een DGE-analyse moet de p-waarde voor elk gen berekend worden. In dit geval 28.395 genen. Hiervoor moeten de p-waarden worden gecorrigeerd. De output van het DESeq2-pakket geeft zowel ongecorrigeerde p-values, als gecorrigeerde p-waardes padj (p-adjusted). Op basis van p-waarden alleen kan echter niet geconcludeerd worden of de expressie van genen toeneemt ( upreguleerd ) of afneemt ( downreguleerd ). Hiervoor berekent DESeq2 ook de fold change. De fold changes worden gerapporteerd als log2 fold changes (LFC). Dat betekent dat de log2 van de fold change wordt genomen. Stel dat een gen een 4x verhoogde expressie ( = upregulated ) heeft in cellen behandeld met BCLXL vergeleken met behandelde cellen met ONECUT2. De LFC zou dan log2(4) = 2 zijn. Op dezelfde manier geeft een LFC van 2 een 4x (2^2) toename in genexpressie aan in de BCLXL behandelde cellen. Uitvoering van DGE analyse # Uitvoer DGE analyse fibroblasten_dge &lt;- DESeq(dds) Na de uitvoering van de DGE analyse, kunnen de resultaten van de DGE analyse bekeken worden met behulp van de **results()* functie. #Verkrijgt de resultaten van de DGE Analyse. fibroblasten_dge_results &lt;- results(fibroblasten_dge, alpha = 0.01, lfcThreshold = 1) fibroblasten_dge_results #Verkrijgt een samenvatting van de resultaten. summary(fibroblasten_dge_results) Met deze samenvatting kan gezien worden dat ongeveer 1753 genen upgereguleerd zijn en ongeveer 939 genen downreguleerd zijn als gevolg van de behandeling van fibroblasten met ONECUT2 ten opzichte van BCLXL. Visualisatie van de DGE resultaten. Om de resultaten van de DGE analyse te visualiseren, worden gebruik gemaakt van volcano plots en heatmaps. Volcano Plots In deze grafiek worden de significant verschillende genen, met een padj &lt; 0.01, onderscheiden worden door een donkeroranje kleur. De naam van het meest significante upgereguleerde gen wordt ook toegevoerd. # Creert een dataframe voor plotting without genes with NA&#39;s values fibroblasten_dge_plotting &lt;- data.frame(fibroblasten_dge_results) %&gt;% filter(!is.na(padj)) # Maak een kolom waar je vertelt of het gen een significante verschil heeft. fibroblasten_dge_plotting &lt;- fibroblasten_dge_plotting %&gt;% mutate(signif = if_else(padj &lt; 0.01 &amp; abs(log2FoldChange) &gt; 1, &quot;Significant&quot;, &quot;Not significant&quot;)) # Maak objecten met het aantal upgereguleerde en downgereguleerd genen up_genen &lt;- fibroblasten_dge_plotting %&gt;% filter(padj &lt; 0.01 &amp; log2FoldChange &gt; 1) %&gt;% nrow() down_genen &lt;- fibroblasten_dge_plotting %&gt;% filter(padj &lt; 0.01 &amp; log2FoldChange &lt; -1) %&gt;% nrow() # Maak een volcano plot fibroblasten_dge_plotting %&gt;% ggplot(aes(x = log2FoldChange, y = -log10(padj), color = signif)) + geom_point() + geom_vline(xintercept = 1, linetype=&quot;dashed&quot;) + geom_vline(xintercept = -1, linetype=&quot;dashed&quot;) + geom_hline(yintercept = -log10(0.01), linetype=&quot;dashed&quot;) + xlab(&quot;log2 fold change&quot;) + ylab(&quot;-log10 adjusted p-value&quot;) + ggtitle(&quot;Fig 5: Volcano plot met de significante genen \\n van het fibroblast transdifferentiatie onderzoek&quot;)+ theme_bw() + # Veranderd de legende van de tekst en kleur scale_colour_manual(values = c(&quot;grey&quot;, &quot;darkorange&quot;), name = &quot;Significance&quot;) + # het aantal upgereguleerde en downgereguleerd genen annotate(&quot;text&quot;, x = -5, y = 200, label = paste(&quot;Downgereguleerde \\n genen:&quot;, down_genen ), colour = &quot;darkorange&quot;) + annotate(&quot;text&quot;, x = 8, y = 200, label = paste(&quot;Upgereguleerde \\n genen:&quot;, up_genen ), colour = &quot;darkorange&quot;) Heatmaps Een heatmap wordt gebruikt om te zien welke genen zijn up- en downgereguleerd tijdens het transdifferentiatie proces. Hiervoor worden eerst de top 5 up- en downgereguleerde genen geselecteerd en vervolgens geplot in een heatmap. #Verkrijgt genen met een significante p-waarde sign_genes &lt;- fibroblasten_dge_results[which(fibroblasten_dge_results$padj &lt; 0.01),] # Verkrijgt de 5 meeste significante upgenen top5_upgenen &lt;- rownames(sign_genes[order(sign_genes$log2FoldChange, decreasing = TRUE)[1:5], ]) # Verkrijgt de 5 meeste significante downgenen top5_downgenen &lt;- rownames(sign_genes[order(sign_genes$log2FoldChange, decreasing = FALSE)[1:5], ]) # Combinneer de twee top 5 genen in een object top_genen &lt;- c(top5_upgenen, top5_downgenen) # Verkrijgt de count values voor de top 5 upgenen count_values &lt;- assay(dds)[top_genen,] # Vervang de kolom namen met de condities colnames(count_values) &lt;- colData(dds)$treatment # Visualiseert de resultaten in een heatmap( genormaliseerd) pheatmap(count_values, scale = &quot;row&quot;, show_rownames = TRUE) Onderdeel 4: Ontdekt welke genen veranderen De top 5 up- en downgereguleerde genen zijn nu gevonden. Echter zijn alleen de Entrez-identificatienummers voor deze genen zichtbaar. Aangezien dit niet veel informatie verschaft, worden de gen symbolen aangegeven door middel van de Entrex-identificatienummers m.b.v de mapIds() functie. mapIds(functie) Deze functie wordt gebruikt om identificatienummers van genen of eiwitten om te zetten naar andere identificatienummers of annotaties, zoals het omzetten van Entrez-genen naar symbolen of omgekeerd. Bijvoorbeeld als je een lijst hebt met Entrez-gen-ID’s en je wilt de corresponderende gen-symboolnamen verkrijgen, kun je mapIds() gebruiken om deze conversie uit te voeren. Dit maakt gebruik van een annotatie-database die beschikbaar is in pakketten zoals org.Hs.eg.db (voor menselijke genen). # Omzet de 5 meeste significante upgenen in een dataframe top5_upgenen &lt;- sign_genes[order(sign_genes$log2FoldChange, decreasing = TRUE)[1:5],] %&gt;% as.data.frame() # Omzet de 5 meeste significante downgenen in een dataframe top5_downgenen &lt;- sign_genes[order(sign_genes$log2FoldChange, decreasing = FALSE)[1:5],] %&gt;% as.data.frame() # Combinneer de twee top 5 genen in een dataframe top_genen &lt;- rbind(top5_upgenen, top5_downgenen) knitr::kable(head(top_genen)) # Voeg een extra kolom aan de dataframe met Entrez id (Gebaseerd op de rijennamen) top_genen &lt;- top_genen %&gt;% mutate(entrezid = rownames(top_genen)) # Verkrijgt de gen symbolen gebaseerd ip de Entrez identifiers top_genen$symbol &lt;- mapIds(org.Hs.eg.db, keys = top_genen$entrezid, column = &quot;SYMBOL&quot;, keytype = &quot;ENTREZID&quot;, multiVals = &quot;first&quot;) knitr::kable(head(top_genen)) Nu dat de gensymbolen van de top 5 up- en downgereguleerde genen gevonden zijn, kunnen deze gensymbolen gebruikt worden in de heatmap als ‘rownames’. #Maak een object met DE-genen symbolen symbolen &lt;- top_genen$symbol # Veranderd de rijen namen voor de top 5 up- en downgereguleerde gene symbolen rownames(count_values) &lt;- symbolen # Visualiseert de resultaten in de heatmap met de DE-genen(genormaliseerd) pheatmap(count_values, scale = &quot;row&quot;, show_rownames = TRUE) Met de verkregen heatmap is duidelijk zichtbaar welke genen **up- of downgereguleerd* zijn. Echter is hieruit niet duidelijk welke biologische processen geassocieerd met de genen up- of downgereguleerd zijn. Hiertoe wordt een GO enrichment term uitgevoerd op de 10 genen. Cytogenetische band functie cytogenbandToEntrex &lt;- function(cytogen_band) { # Verkrijg de cytogene mapping gebaseerd op de entrex IDs voor de 10 genen. top_genen$chromosomal_band &lt;- mapIds(org.Hs.eg.db, keys = top_genen$entrezid, column = &quot;MAP&quot;, keytype = &quot;ENTREZID&quot;, multiVals = &quot;first&quot;) chromband_to_entrezid &lt;- top_genen %&gt;% filter(chromosomal_band == cytogen_band) entrezid_chromband &lt;- chromband_to_entrezid$entrezid return(entrezid_chromband) } #Voorbeeld: chromosomal band geeft entrex id terug. cytogenbandToEntrex(&quot;7p21.2&quot;) Uitvoer GO term enrichment analyse Zoals eerder aangegeven, ligt de interesse niet alleen bij welke genen zijn up- en downgereguleerd na behandeling, maar welke biologische processen deze genen beïnvloeden. Hiertoe wordt een GO tern enrichment analyse uitgevoerd. Er wordt hiervoor gebruik gemaakt van de speciale software GOstats-pakket in R en functie hyperGtest(). Zo wordt een duidelijk beeld geschetst tussen te verschillen in genexpressie in fibroblasten na behandeling met ONECUT2 of BCLXL. Om herhalende code te voorkomen, is een functie ontworpen om de GO term enrichment analyse voor up- en downgereguleerde genen makkelijker en sneller uit te voeren. GO term enrichment analyse functie # GO term enrichment analysis functie goTermAnalysis_fibroblasten &lt;- function(dge_results, upregulated, lfc_value, padj_value) { # Maak een lijst van alle genen in de dataset all_fibroblasten_genen &lt;- dge_results %&gt;% data.frame() %&gt;% rownames() if (upregulated==TRUE) { # Maak een lijst van alle upgereguleerde genen upregulated_fibroblasten_genen &lt;- dge_results %&gt;% data.frame() %&gt;% filter(log2FoldChange &gt; lfc_value, padj &lt; padj_value) %&gt;% rownames() #Uitvoer GO term enrichment analysis test_object_fibroblasten_up &lt;- new(&quot;GOHyperGParams&quot;, geneIds = upregulated_fibroblasten_genen, universeGeneIds = all_fibroblasten_genen, annotation = &quot;org.Hs.eg.db&quot;, ontology = &quot;BP&quot;, pvalueCutoff = 1, testDirection = &quot;over&quot;) goterm_analysis_up_summary &lt;- summary(hyperGTest(test_object_fibroblasten_up)) return(goterm_analysis_up_summary) } else { # Maak een lijst van alle downgereguleerde genen downregulated_fibroblasten_genen &lt;- dge_results %&gt;% data.frame() %&gt;% filter(log2FoldChange &lt; -lfc_value, padj &lt; padj_value) %&gt;% rownames() #Uitvoer GO term enrichment analysis test_object_fibroblasten_down &lt;- new(&quot;GOHyperGParams&quot;, geneIds = downregulated_fibroblasten_genen, universeGeneIds = all_fibroblasten_genen, annotation = &quot;org.Hs.eg.db&quot;, ontology = &quot;BP&quot;, pvalueCutoff = 1, testDirection = &quot;over&quot;) goterm_analysis_down_summary &lt;- summary(hyperGTest(test_object_fibroblasten_down)) return(goterm_analysis_down_summary) } } Vervolgens wordt de functie uitgevoerd voor upgereguleerde genen en downgereguleerde genen met een LFC van 1 en -1 en een padj van &lt;0.01. Top 20 Upgereguleerde genen #Upregulated # Maak een dataframe met de samenvatting van de resultaten van GO term analysis summary_fibroblasten_up_GOterm &lt;- goTermAnalysis_fibroblasten(fibroblasten_dge_results, upregulated = TRUE, 1, 0.01) # Pas de p-waarden aan voor meervoudige testen. summary_fibroblasten_up_GOterm$padj &lt;- p.adjust(summary_fibroblasten_up_GOterm$Pvalue, method = &quot;BH&quot;) # Selecteer alleen genensets die groter zijn dan 5 maar kleiner dan 500 # (om te voorkomen dat zeer kleine en zeer grote genensets worden meegenomen). summary_fibroblasten_up_GOterm &lt;- summary_fibroblasten_up_GOterm %&gt;% filter(Count &gt; 5) %&gt;% filter(Count &lt; 500) # Kies de top 20 GO termen goterm_analysis_up_summary_top20 &lt;- summary_fibroblasten_up_GOterm[order(summary_fibroblasten_up_GOterm$padj)[1:20],] # Plot p-waardes van de top 20 uogereguleerde GO termen goterm_analysis_up_summary_top20$Term &lt;- factor(goterm_analysis_up_summary_top20$Term, levels = goterm_analysis_up_summary_top20$Term[ order(goterm_analysis_up_summary_top20$padj, decreasing = TRUE)]) goterm_analysis_up_summary_top20 %&gt;% ggplot(aes(x = Term, y = -log10(padj))) + geom_point() + coord_flip() + ylab(expression(-log[10](adjusted~italic(P)~value))) + xlab(&quot;GO terms&quot;) + ggtitle(&quot;Fig 6: Top 20 enriched GO termen\\n voor upgereguleerde genen&quot;) + theme_bw() Na het uitvoeren van de GO term enrichment analyse voor upgereguleerde genen, is zichtbaar in figuur 5 dat na behandeling met transcriptiefactor ONECUT2 genen worden upgereguleerd die betrokken zijn bij onder andere de volgende biologische processen: Ontwikkeling van zenuwstelsel en organen (Development), chemische signalering (Signaling), DNA- en RNA-transcriptie (Transcription) en cel apoptose. Top 20 Downgereguleerde genen #Downregulated # Maak een dataframe met de samenvatting van de resultaten van GO term analysis summary_fibroblasten_down_GOterm &lt;- goTermAnalysis_fibroblasten(fibroblasten_dge_results, upregulated = FALSE, 1, 0.01) # Pas de p-waarden aan voor meervoudige testen. summary_fibroblasten_down_GOterm$padj &lt;- p.adjust(summary_fibroblasten_down_GOterm$Pvalue, method = &quot;BH&quot;) # Selecteer alleen genensets die groter zijn dan 5 maar kleiner dan 500 # (om te voorkomen dat zeer kleine en zeer grote genensets worden meegenomen). summary_fibroblasten_down_GOterm &lt;- summary_fibroblasten_down_GOterm %&gt;% filter(Count &gt; 5) %&gt;% filter(Count &lt; 500) # Kies de top 20 GO termen goterm_analysis_down_summary_top20 &lt;- summary_fibroblasten_down_GOterm[order(summary_fibroblasten_down_GOterm$padj)[1:20],] # Plot p-waardes van de top 20 downgereguleerde GO termen goterm_analysis_down_summary_top20$Term &lt;- factor(goterm_analysis_down_summary_top20$Term, levels = goterm_analysis_down_summary_top20$Term[ order(goterm_analysis_down_summary_top20$padj, decreasing = TRUE)]) goterm_analysis_down_summary_top20 %&gt;% ggplot(aes(x = Term, y = -log10(padj))) + geom_point() + coord_flip() + ylab(expression(-log[10](adjusted~italic(P)~value))) + xlab(&quot;GO terms&quot;) + ggtitle(&quot;Fig 7: Top 20 enriched GO termen\\n voor downgereguleerde genen&quot;) + theme_bw() Na het uitvoeren van de GO term enrichment analyse voor downgereguleerde genen, is zichtbaar in figuur 6 dat na behandeling met transcriptiefactor ONECUT2 genen worden downgereguleerd die betrokken zijn bij onder andere de volgende biologische processen: Het ontwikkelen van structuur van weefsels en cellen (Development), morfogenese van de cel-structuur (Morphogenesis), cel beweging en motiliteit. Conclusie Op basis van de verkregen resultaten van de RNA-sequencing analyse kan er geconcludeerd worden dat er een significant verschil is in genexpressie en biologische functies tussen fibroblasten behandeld met BCLXL en ONECUT2 . Dit wordt aangetoond door de resultaten van de “Differential Gene Expression” analyse en de “GO term enrichment” analyse. Bij de “Differential Gene Expression” analyse en plots (PCA en Volcano plots), is het zichtbaar dat meerdere genen een significant verschil in hun genexpressie vertonen. Deze veranderingen in genexpressie vormen een duidelijk signaal dat er een verschil is tussen fibroblasten behandeld met BCLXL en ONECUT2. Bij de “GO term enrichment” analyse, zoals zichtbaar in figuur 6, zijn de biologische functies die upgereguleerd worden tijdens het transdifferentiatieproces van de fibroblasten na behandeling met ONECUT2 geassocieerd met de ontwikkeling van het zenuwstelsel en organen (Development), chemische signalering (Signaling) en DNA- en RNA-transcriptie (Transcription). Deze upgereguleerde biologische functies zijn een goed signaal dat de overexpressie van de transcriptiefactor ONECUT2 ervoor zorgt dat de fibroblasten differentiëren naar hersencellen. Dit suggereert dat de fibroblasten hun structuur veranderen en zich dus klaarmaken om andere functies uit te voeren. Echter zien we ook dat sommige biologische functies die upgereguleerd worden tijdens het transdifferentiatieproces van de fibroblasten geassocieerd zijn met cel-apoptose. Dit suggereert dat de fibroblasten zich ook klaarmaken om dood te gaan als het transdifferentiatie proces zorgt voor problemen. Met behulp van figuur 7 is zichtbaar dat de biologische functies die downgereguleerd worden tijdens het transdifferentiatieproces van de fibroblasten, geassocieerd zijn met de ontwikkeling van de structuur van weefsels en cellen (Development), morfogenese van de celstructuur (Morphogenesis) en celbeweging en motiliteit. Dus fibroblasten verliezen hun structuur en dus ook hun functie. Dit suggereert dat de fibroblasten zich klaarmaken om een andere structuur te krijgen en andere functies uit te voeren, zoals gebeurd bij differentiatie naar hersencellen. Op basis van de verkregen resultaten van de “GO term enrichment” analyse kan ook geconcludeerd worden dat fibroblasten behandeld met ONECUT2 van structuur veranderen en dus ook van functie. Dus fibroblasten behandeld met ONECUT2 maken zich klaar om hersencellen te worden, echter is er ook een risico dat fibroblasten een apoptotisch proces ondergaan door complicaties tijdens het transdifferentiatie proces. Discussie Het is belangrijk op te merken dat de betrouwbaarheid van de resultaten van deze RNA sequencing analyse verminderd wordt door de resultaten van figuren 1 en 3. In figuur 1 blijkt het aantal toegewezen fragmenten laag en uit figuur 3 blijkt dat er een verschil aanwezig is tussen de duplo metingen van de behandelingen. Dit kan mogelijk ontstaan zijn door contaminatie tijdens het onderzoek. Dit kan invloed hebben gehad op de interpretatie van de up- en downregulatie van de biologische processen. Het wordt aangeraden om hierdoor het experiment te herhalen. "],["metagenomics.html", "Metagenomics Data Structure: Onderdeel 1 Onderdeel 2 Onderdeel 3 Onderdeel 4", " Metagenomics Data Structure: The data structure of this project is the next one: Datatree of the “Metagenomics” project Note 1: The data need it for this project is property of “Hogeschool Utrecht, thus due copyright and privacy laws I’m not avaible to share most of data used for this experiment.But you can still read the documentation and code of this experiment. Note 2: The language used in this is project is Dutch Onderdeel 1 FastQC genereren # activate environment conda activate meta # perform FastQC analysis fastqc -o ~/metagenomics/data/fastqc_output /home/daur2/metagenomics/formative_data/HU2_MOCK2_L001_R1_001.fastq.gz fastqc -o ~/metagenomics/data/fastqc_output /home/daur2/metagenomics/formative_data/HU2_MOCK2_L001_R2_001.fastq.gz # deactivate conda virtual environment conda deactivate Per base sequencing quality Onderdeel 2 Kraken2 uitvoeren # activate environment conda activate meta kraken2 --db /home/daur2/metagenomics/minikraken2_v2_8GB_201904_UPDATE/ --threads 2 --paired --gzip-compressed --output ~/metagenomics/mock2/mock2.kraken --report ~/metagenomics/data/mock2/mock2.report --use-names /home/daur2/metagenomics/formative_data/HU2_MOCK2_L001_R1_001.fastq.gz /home/daur2/metagenomics/formative_data/HU2_MOCK2_L001_R2_001.fastq.gz conda deactivate Er zijn 65915836 sequences verwerkt, waarvan 59541308 zijn geklassificeerd en 6374528 niet zijn geklassificeerd. De procedure heeft 963.827 seconden, 16,06 minuten, geduurd (4103.4 Kseq/m, 1210.17 Mbp/m). Bracken uitvoeren # activate environment conda activate meta bracken -d /home/daur2/metagenomics/minikraken2_v2_8GB_201904_UPDATE/ -i ~/metagenomics/data/mock2/mock2.report -o ~/metagenomics/data/bracken/mock2.bracken conda deactivate Kraken-biom uitvoeren # activate environment conda activate meta kraken-biom ~/metagenomics/data/mock2/mock2_bracken_species.report --fmt json -o ~/metagenomics/data/mock2/mock2_bracken_species.biom conda deactivate Onderdeel 3 # load nessecary packages library(&quot;phyloseq&quot;) library(&quot;ggplot2&quot;) Read count visualisatie per kingdom data_mock2 &lt;- here::here(&quot;projects/metagenomics/data/mock2/mock2_bracken_species.biom&quot;) merged_metagenomes_mock2 &lt;- import_biom(data_mock2) # Verwijder taxonomische informatie uit waarden/ verwijder eerste vier tekens merged_metagenomes_mock2@tax_table@.Data &lt;- substring(merged_metagenomes_mock2@tax_table@.Data, 4) # Hernoem kolomkoppen naar informatieve indeling colnames(merged_metagenomes_mock2@tax_table@.Data) &lt;- c(&quot;Kingdom&quot;, &quot;Phylum&quot;, &quot;Class&quot;, &quot;Order&quot;, &quot;Family&quot;, &quot;Genus&quot;, &quot;Species&quot;) # Haal de aanwezige taxonomische rijken uit onze data op unique(merged_metagenomes_mock2@tax_table@.Data[,&quot;Kingdom&quot;]) ## [1] &quot;Bacteria&quot; &quot;Eukaryota&quot; &quot;Archaea&quot; &quot;Viruses&quot; Er zitten bacteriën, eukaryoten, archaea en virus genomen in de dataset. Het kan zijn dat de virus genomen in de dataset zijn gekomen door contaminatie. # Subset rijken (Kingdoms) merged_metagenomes_mock2_b &lt;- subset_taxa(merged_metagenomes_mock2, Kingdom == &quot;Bacteria&quot;) merged_metagenomes_mock2_e &lt;- subset_taxa(merged_metagenomes_mock2, Kingdom == &quot;Eukaryota&quot;) merged_metagenomes_mock2_a &lt;- subset_taxa(merged_metagenomes_mock2, Kingdom == &quot;Archaea&quot;) merged_metagenomes_mock2_v &lt;- subset_taxa(merged_metagenomes_mock2, Kingdom == &quot;Viruses&quot;) # Hernoemd samples sample_names(merged_metagenomes_mock2_b) &lt;- &quot;bacteria&quot; sample_names(merged_metagenomes_mock2_e) &lt;- &quot;eukaryote&quot; sample_names(merged_metagenomes_mock2_a) &lt;- &quot;archea&quot; sample_names(merged_metagenomes_mock2_v) &lt;- &quot;virus&quot; # Telt het aantal reads in totaal sample_sums(merged_metagenomes_mock2) ## sa1 ## 59538284 # Telt het aantal reads per rijk (kingdom) c(sample_sums(merged_metagenomes_mock2_b), sample_sums(merged_metagenomes_mock2_e), sample_sums(merged_metagenomes_mock2_a), sample_sums(merged_metagenomes_mock2_v)) ## bacteria eukaryote archea virus ## 59491948 18373 263 27700 # Verzamel de rijken (kingdoms)in data frames data_mock2_b &lt;- data.frame(Samples = sample_names(merged_metagenomes_mock2_b), Reads = sample_sums(merged_metagenomes_mock2_b)) data_mock2_e &lt;- data.frame(Samples = sample_names(merged_metagenomes_mock2_e), Reads = sample_sums(merged_metagenomes_mock2_e)) data_mock2_a &lt;- data.frame(Samples = sample_names(merged_metagenomes_mock2_a), Reads = sample_sums(merged_metagenomes_mock2_a)) data_mock2_v &lt;- data.frame(Samples = sample_names(merged_metagenomes_mock2_v), Reads = sample_sums(merged_metagenomes_mock2_v)) # Voeg kingdom data in een dataframe data_mock2_t &lt;- rbind(data_mock2_b, data_mock2_e, data_mock2_a, data_mock2_v) # Plot het aantal reads per rijk ggplot(data = data_mock2_t, mapping = aes(x = Samples, y = Reads, fill = Samples )) + geom_col() + theme_classic() + ggtitle(&quot;Read count per kingdom&quot;) + theme(plot.title = element_text(hjust = 0.5)) + theme(axis.text.x=element_text(angle=45, hjust=1)) Visualiseren van geïdentificeerde soorten # Herlaad de biom-gegevens, bewerk kolomkoppen en sample name merged_metagenomes_mock2 &lt;- import_biom(data_mock2) merged_metagenomes_mock2@tax_table@.Data &lt;- substring(merged_metagenomes_mock2@tax_table@.Data, 4) colnames(merged_metagenomes_mock2@tax_table@.Data)&lt;- c(&quot;Kingdom&quot;, &quot;Phylum&quot;, &quot;Class&quot;, &quot;Order&quot;, &quot;Family&quot;, &quot;Genus&quot;, &quot;Species&quot;) colnames(merged_metagenomes_mock2@otu_table) &lt;- c(&quot;mock2&quot;) # check lege labels (empty = TRUE) summary(merged_metagenomes_mock2@tax_table@.Data== &quot;&quot;) ## Kingdom Phylum Class Order Family Genus Species ## Mode :logical Mode :logical Mode :logical Mode :logical Mode :logical Mode :logical Mode :logical ## FALSE:863 FALSE:847 FALSE:835 FALSE:861 FALSE:860 FALSE:855 FALSE:863 ## TRUE :16 TRUE :28 TRUE :2 TRUE :3 TRUE :8 # transformeer data frame voor plotten glom_mock2 &lt;- tax_glom(merged_metagenomes_mock2, taxrank = &quot;Species&quot;) mock2_metagenome_species &lt;- psmelt(glom_mock2) # Combineer genus- en soortlabels voor wetenschappelijke benaming in de plot mock2_metagenome_species$Species &lt;- as.character(mock2_metagenome_species$Species) mock2_metagenome_species$Species &lt;- paste(mock2_metagenome_species[,]$Genus,mock2_metagenome_species[,]$Species, sep=&quot; &quot;, collapse=NULL) # Controleer labelmanipulatie #unique(mock2_metagenome_species$Species) id_species_mock2 &lt;- ggplot(data=mock2_metagenome_species, aes(x=Sample, y=Abundance, fill=Species))+ geom_bar(aes(), stat=&quot;identity&quot;, position=&quot;stack&quot;) id_species_mock2 Optimalisatie door verwijdering van soorten met lage read counts mock2_metagenome_species$Species[mock2_metagenome_species$Abundance &lt; 160000] &lt;- &quot;Species &lt; 160.000 abund.&quot; id_species_mock2 &lt;- ggplot(data=mock2_metagenome_species, aes(x=Sample, y=Abundance, fill=Species))+ geom_bar(aes(), stat=&quot;identity&quot;, position=&quot;stack&quot;) id_species_mock2 Normalisatie # Normaliseren van de read counts # transformeer read counts naar percentages glom_mock2 &lt;- tax_glom(merged_metagenomes_mock2, taxrank = &quot;Species&quot;) mock2_metagenome_species_percent &lt;- psmelt(glom_mock2) # Normaliseert read counts percentages mock2_metagenome_species_percent$Abundance &lt;- (mock2_metagenome_species_percent$Abundance*100)/sum(mock2_metagenome_species_percent$Abundance) # Combineert genus and species label for scientific noemen in het plot mock2_metagenome_species_percent$Species &lt;- as.character(mock2_metagenome_species_percent$Species) mock2_metagenome_species_percent$Species &lt;- paste(mock2_metagenome_species_percent[,]$Genus,mock2_metagenome_species_percent[,]$Species, sep=&quot; &quot;, collapse=NULL) mock2_metagenome_species_percent$Species[mock2_metagenome_species_percent$Abundance &lt; 0.5] &lt;- &quot;Species &lt; 0.5% abund.&quot; #unique(mock2_metagenome_species_percent$Species) id_species_mock2_percent &lt;- ggplot(data=mock2_metagenome_species_percent, aes(x=Sample, y=Abundance, fill=Species))+ geom_bar(aes(), stat=&quot;identity&quot;, position=&quot;stack&quot;) # plot species identificatie grid.arrange(id_species_mock2, id_species_mock2_percent, ncol=2, top=textGrob(&quot;Identified species and their corresponding abundance\\nread count (right) and percentage (left)\\n&quot;, gp=gpar(fontsize=12,font=8))) Onderdeel 4 Verkrijgen van compositie data # Verkrijgen van compositie data mock2_composition &lt;- as.data.frame(read.csv(&#39;/home/daur2/metagenomics/formative_data/HU_waternet_MOCK2_composition.csv&#39;, row.names=1, sep = &quot;;&quot;)) mock2_composition$amount &lt;- as.numeric(gsub(&quot;,&quot;, &quot;.&quot;, mock2_composition$amount)) mock2_composition &lt;- mock2_composition %&gt;% mutate(amountP = (amount / total_volume) * 100) colnames(mock2_composition) &lt;- c( &quot;name&quot;,&quot;amount&quot;,&quot;sample_name&quot;,&quot;total_volume&quot;,&quot;amountP&quot;) # Intersect databases to collect overlap between composition and `kraken2` results mock2_and_composition_intersect &lt;- mock2_metagenome_species_percent[mock2_metagenome_species_percent$Species %in% mock2_composition$name,] # collect species that are in composition and not in `kraken2` results `%!in%` &lt;- Negate(`%in%`) # allow not in = !in comp_not_in_mock2 &lt;- mock2_composition[mock2_composition$name %!in% mock2_metagenome_species_percent$Species,] # generate a list of species overlap between mock1 and composition unique(mock2_and_composition_intersect$Species) # generate a list of species that are from composition and not in mock1 unique(comp_not_in_mock2$name) Vergelijking van resultaten met compositie # compare labels between `kraken2` subset and composition and store percent values when labels are identical mock2_and_composition_intersect$amountP &lt;- NA for (m2_label in mock2_and_composition_intersect$Species){ for (m2c_label in mock2_composition$name){ if(m2_label == m2c_label){ mock2_and_composition_intersect$amountP[mock2_and_composition_intersect$Species == m2_label] &lt;- mock2_composition$amountP[mock2_composition$name == m2c_label] } } } # load library for melting data frame library(reshape2) # collect plotting info and pretify layout format #colnames(mock1_and_composition_intersect) mock2_and_comp_plotting_data &lt;- mock2_and_composition_intersect[,c(10,3,11)] colnames(mock2_and_comp_plotting_data) &lt;- c(&quot;species&quot;, &quot;k_abundance&quot;, &quot;c_abundance&quot;) mock2_and_comp_plotting_data &lt;- melt(mock2_and_comp_plotting_data, id.var = &quot;species&quot;) mock2_and_comp_plotting_data$value &lt;- as.numeric(mock2_and_comp_plotting_data$value) ggplot(mock2_and_comp_plotting_data, aes(x = species, y = value, fill = variable)) + geom_bar(aes(), stat=&quot;identity&quot;, position=&quot;dodge&quot;) + theme_classic() + ylab(&quot;Abundance (%)&quot;) + xlab(&quot;&quot;) + ggtitle(&quot;Abundance comparison between Kraken2 results and composition&quot;) + theme(plot.title = element_text(hjust = 0.5)) + ylim(0,25) + theme(axis.text.x = element_text(angle = -45, hjust = 0, vjust = 1)) + scale_fill_manual(values=c(&quot;skyblue&quot;, &quot;orangered&quot;)) We hebben bracken gebruikt om de waardes in te schatten. Het kan daardoor zijn dat de compositie file niet overeenkomt. "],["c.-elegans-plate-analysis.html", "C. elegans plate analysis Metadata Inspect file Making a scatterplot How I would analyze this data for a typical analysis of dose-response? Normalizing the data of the negative control", " C. elegans plate analysis Metadata The data for this project was kindly supplied by J. Louter (INT/ILC) and was derived from an experiment in which adult C.elegans nematodes were exposed to varying concentrations of different compounds. The most relevant variables for the analysis of this project are: RawData: The outcome/number of offspring counted as an integer value, after incubation time. compName: The generic name of the compound/chemical. compConcentration: The concentration of the compound expType: The type of each experiment (Test, positive- and negative control) A typical analysis for this data would be to run a dose-response analysis using a log-logistic model with estimates for the maximal, the minimal, the IC50 concentration and the slope at IC50. But before that we have to control, if our data was correctly import. Inspect file First, let’s import the data of the experiment file with the function read_excel() # Import the file experiment &lt;- read_excel(here::here(&quot;projects/celegans_plate/data/CE.LIQ.FLOW.062_Tidydata.xlsx&quot;)) #Show the first 6 rows of the data knitr::kable(head(experiment)) plateRow plateColumn vialNr dropCode expType expReplicate expName expDate expResearcher expTime expUnit expVolumeCounted RawData compCASRN compName compConcentration compUnit compDelivery compVehicle elegansStrain elegansInput bacterialStrain bacterialTreatment bacterialOD600 bacterialConcX bacterialVolume bacterialVolUnit incubationVial incubationVolume incubationUnit incubationMethod incubationRPM bubble incubateTemperature NA NA 1 a experiment 3 CE.LIQ.FLOW.062 2020-11-30 Sergio Reijnders - Ellis Herder 68 hour 50 44 24157-81-1 2,6-diisopropylnaphthalene 4.99 nM Liquid controlVehicleA N2 25 OP50 heated 0.743 8 300 ul 1,5 glass vial 1000 ul rockroll 35 NA 20 NA NA 1 b experiment 3 CE.LIQ.FLOW.062 2020-11-30 Sergio Reijnders - Ellis Herder 68 hour 50 37 24157-81-1 2,6-diisopropylnaphthalene 4.99 nM Liquid controlVehicleA N2 25 OP50 heated 0.743 8 300 ul 1,5 glass vial 1000 ul rockroll 35 NA 20 NA NA 1 c experiment 3 CE.LIQ.FLOW.062 2020-11-30 Sergio Reijnders - Ellis Herder 68 hour 50 45 24157-81-1 2,6-diisopropylnaphthalene 4.99 nM Liquid controlVehicleA N2 25 OP50 heated 0.743 8 300 ul 1,5 glass vial 1000 ul rockroll 35 NA 20 NA NA 1 d experiment 3 CE.LIQ.FLOW.062 2020-11-30 Sergio Reijnders - Ellis Herder 68 hour 50 47 24157-81-1 2,6-diisopropylnaphthalene 4.99 nM Liquid controlVehicleA N2 25 OP50 heated 0.743 8 300 ul 1,5 glass vial 1000 ul rockroll 35 NA 20 NA NA 1 e experiment 3 CE.LIQ.FLOW.062 2020-11-30 Sergio Reijnders - Ellis Herder 68 hour 50 41 24157-81-1 2,6-diisopropylnaphthalene 4.99 nM Liquid controlVehicleA N2 25 OP50 heated 0.743 8 300 ul 1,5 glass vial 1000 ul rockroll 35 NA 20 NA NA 2 a experiment 3 CE.LIQ.FLOW.062 2020-11-30 Sergio Reijnders - Ellis Herder 68 hour 50 35 24157-81-1 2,6-diisopropylnaphthalene 4.99 nM Liquid controlVehicleA N2 25 OP50 heated 0.743 8 300 ul 1,5 glass vial 1000 ul rockroll 35 NA 20 Inspect data/variables Now that we have import the data of the experiment let’s check if the type of the imported data correspond with the expected data for the each variable: Raw Data Expected type of data = Numeric (Integer) Type of data = double compName Expected type of data = character Type of data = double compConcentration Expected type of data = Numeric (Double) Type of data = character After checking the data type for each variable, it has been found that the data type of the variable “compConcentration” does not correspond to the expected type. The reason for this error is that during the data import from Excel, the expression for the exponent of the numeric values in Excel, such as “1-E01,” is interpreted as a character in R. To correct this, we need to convert this variable to numeric data using the following code: Changing type of data experiment$compConcentration &lt;- as.numeric(experiment$compConcentration) ## Warning: NAs introduced by coercion Type of data now = double Making a scatterplot After inspecting the data of the experiment we can make an exploratory plot to identify the set up of this experiment. For this plot we will use the following code: experiment %&gt;% ggplot(aes(x=log10(compConcentration + .001), y=RawData, group = compName, colour = compName, shape = expType)) + geom_point(na.rm = TRUE, position = position_jitter(width = 0.1))+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + labs(title = &quot;Fig 1: Scatterplot for C.elegans plate experiment&quot;, x=&quot;Log_Compound Concentration&quot;, y=&quot;Count offspring&quot;, color = &quot;Compound Name&quot;, shape = &quot;Type of experiment&quot;) Note: For clearer view of the data of this experiment I have use jitter for the plotting of Figure 1. Jitter refers to the random variation added to the position of points along an axis. It is commonly used to prevent points with identical or very close values from overlapping, thus improving the clarity of the plot. With the help of the exploratory plot “Figure 1” we can make the following conclusions: The positive control for this experiment is Ethanol. The negative control for this experiment is S-medium. How I would analyze this data for a typical analysis of dose-response? First, I will do the previous steps in this project. These steps are “Data exploration” and “Exploring visualization”. Because with these steps I can identify the most relevant variables and data for the plotting of a dose-response curve. After identifying the most relevant variables and data. I would plot a dose-response curve with the help of the drc package. This will generate a model with the maximal, minimal, he IC50 concentration and the slope at IC50. After plotting the dose-response curve, I would interpreted the results of this plot and after this I would write my conclusions and discussions points. Normalizing the data of the negative control # Calculate the mean value for controlNegative mean_cont_neg &lt;- mean(experiment$RawData[experiment$expType == &quot;controlNegative&quot;]) # check contNeg_mean mean_cont_neg ## [1] 85.9 # Normalize data experiment$NormalizedData &lt;- experiment$RawData experiment$NormalizedData[experiment$expType != &quot;controlNegative&quot;] &lt;- experiment$NormalizedData[experiment$expType != &quot;controlNegative&quot;] / mean_cont_neg # Multiply by 1 to ensure the mean of controlNegative is equal to 1 experiment$NormalizedData[experiment$expType == &quot;controlNegative&quot;] &lt;- 1 # Check the normalized data knitr::kable(head(experiment %&gt;% select(RawData, NormalizedData, expType))) RawData NormalizedData expType 44 0.5122235 experiment 37 0.4307334 experiment 45 0.5238650 experiment 47 0.5471478 experiment 41 0.4772992 experiment 35 0.4074505 experiment Now that the data has been normalized, let’s plot the normalized data in a new graphic. experiment %&gt;% ggplot(aes(x=log10(compConcentration +.001), y=NormalizedData, group = compName, colour = compName, shape = expType)) + geom_point(na.rm = TRUE, position = position_jitter(width = 0.1))+ # jitter to avoid overlap theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + labs(title = &quot;Fig 2: Scatterplot for C.elegans plate experiment with normalized data.&quot;, x=&quot;Log_Compound Concentration&quot;, y=&quot;Count offspring&quot;, color = &quot;Compound Name&quot;, shape = &quot;Type of experiment&quot;) Why the value of the negative control has to be set to 1? Normalizing the negative control to a value of 1 simplifies data interpretation and comparison between different experimental conditions. It provides a consistent reference point, making it easier to understand how other conditions relate to the control. "],["reproducible-research-skills.html", "Reproducible research skills Open peer review of an article Impressions of the code", " Reproducible research skills Open peer review of an article For this project I’ll be testing my reproducible research skills reviewing the reproducibility and reporting practices of the article; The COVID-19 Pandemic Eroded System Support but not Social Solidarity Article: The COVID-19 Pandemic Eroded System Support but not Social Solidarity Project enviroment of the article My chosen article have the following project enviroment: Project enviroment of the article: the COVID-19 Pandemic Eroded System Support but not Social Solidarity Data structure: With the given project enviroment we will obtain the following data structure: For the rest of this project I’ll be focusing in the R script “agg_plot.R” inside the folder “C-code” Impressions of the code If we open the R script “agg_plot.R” we could find the following code: # a function to calculate quantile for a specific CI width myquantile &lt;- function(ci){ alpha = (100-ci)/2/100 qnorm(1-alpha) } # custom functions for calculating weighted mean and SE which work inside functions mymean &lt;- function(x,w) {wtd.mean(x = x, weights = w, na.rm = T)} myse &lt;- function(x,w) {sqrt(wtd.var(x, weights = w, na.rm = T))/sqrt(length(x))} # Import data ------------------------------------------------------------- df_full &lt;- readRDS(&quot;B-analysis-data/yougov_clean_202204122.rds&quot;) var_lookup &lt;- readRDS(&quot;B-analysis-data/varlookup.rds&quot;) # Figure 1. Benchmarked changes in Solidarity and System support ------------------------------ # ~ Crunch Systemic variables ----------------------------------------------------- system_dvs &lt;- c(&quot;system_satisfaction.z&quot;, &quot;level_democracy.z&quot;, &quot;supp_demcy.z&quot;, &quot;proudcitizen.z&quot;) # 4*3 country-wave means for individual outcomes system_4c &lt;- df_full %&gt;% # subset to relevant vars for system support dplyr::select(country, weight, wavedate, all_of(system_dvs)) %&gt;% # calculate weighted mean by country-waves pivot_longer(all_of(system_dvs), names_to = &quot;dv&quot;) %&gt;% group_by(country, wavedate, dv) %&gt;% summarise(mean = mymean(value, weight), se = myse(value, weight)) %&gt;% glimpse # reported in the text: system_4c %&gt;% group_by(country) %&gt;% summarise(sum(mean &gt; 0)) # reported in the text: system_4c %&gt;% filter(country %in% c(&quot;Denmark&quot;)) %&gt;% filter(dv %in% c(&quot;level_democracy.z&quot;) &amp; wavedate == ymd(&quot;2020-12-12&quot;)) # ---------------------A LOT MORE OF DATA WRANGLING AND ANALYSIS ------------------------ # ~ Draw system plot --------------------------------------------------------- # ~ Panel A of Figure 1 system_facet &lt;- ggplot(system_plotdata, aes( x = wavedate, y = mean, color = dv)) + geom_rect(data = filter(system_plotdata, country == &quot;Pooled&quot;), fill = NA, color = &quot;black&quot;, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf) + geom_hline(aes(yintercept = 0)) + geom_point(size = 1, alpha = .5) + geom_line(aes(group = dv), alpha = .7) + # add extra width to pooled lines geom_line(data = filter(system_plotdata,dv == &quot;Pooled&quot;), size = 1) + # add errorbars only to pooled estimates geom_errorbar(data = filter(system_plotdata,dv == &quot;Pooled&quot;), aes(ymin = mean - myquantile(95)*se, ymax = mean + myquantile(95)*se), size = .6, width = 0) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_color_manual(name = NULL, values = c(&quot;#000000&quot;, viridisLite::viridis(4)), labels = c(&quot;Pooled&quot;, &quot;\\nLevel of \\nDemocracy&quot;, &quot;Proud Citizen&quot;, &quot;\\nSupport for \\nDemocracy&quot;, &quot;\\nSatisf. with \\nPol. System&quot;) ) + scale_x_date(breaks = ymd(c(&quot;2020-04-20&quot;,&quot;2020-06-15&quot;,&quot;2020-12-12&quot;)), limits = ymd(c(&quot;2020-04-01&quot;, &quot;2020-12-31&quot;)), date_labels = &quot;%b&quot;) + ggtitle(&quot;System Support&quot;) + facet_grid(~country) + scale_y_continuous(limits = c(-1, .2)) + theme_minimal() + theme(panel.grid.minor = element_blank()) system_facet ## Rows: 48 ## Columns: 5 ## Groups: country, wavedate [12] ## $ country &lt;chr&gt; &quot;Denmark&quot;, &quot;Denmark&quot;, &quot;Denmark&quot;, &quot;Denmark&quot;, &quot;Denmark&quot;, &quot;Denmark&quot;, &quot;Denmark&quot;, &quot;Denmark&quot;, &quot;Denmark… ## $ wavedate &lt;date&gt; 2020-04-20, 2020-04-20, 2020-04-20, 2020-04-20, 2020-06-15, 2020-06-15, 2020-06-15, 2020-06-15,… ## $ dv &lt;chr&gt; &quot;level_democracy.z&quot;, &quot;proudcitizen.z&quot;, &quot;supp_demcy.z&quot;, &quot;system_satisfaction.z&quot;, &quot;level_democracy… ## $ mean &lt;dbl&gt; -0.69705093, -0.19933124, -0.21590985, -0.06795452, -0.79319215, -0.24868934, -0.26202182, -0.14… ## $ se &lt;dbl&gt; 0.03401541, 0.02883877, 0.02366249, 0.02493922, 0.03692481, 0.03168742, 0.02632567, 0.02744196, … ## # A tibble: 4 × 2 ## country `sum(mean &gt; 0)` ## &lt;chr&gt; &lt;int&gt; ## 1 Denmark 0 ## 2 Hungary 0 ## 3 Italy 1 ## 4 USA 2 ## # A tibble: 1 × 5 ## # Groups: country, wavedate [1] ## country wavedate dv mean se ## &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Denmark 2020-12-12 level_democracy.z -0.916 0.0428 ## Rows: 12 ## Columns: 5 ## Groups: country [4] ## $ country &lt;chr&gt; &quot;Denmark&quot;, &quot;Denmark&quot;, &quot;Denmark&quot;, &quot;Hungary&quot;, &quot;Hungary&quot;, &quot;Hungary&quot;, &quot;Italy&quot;, &quot;Italy&quot;, &quot;Italy&quot;, &quot;US… ## $ wavedate &lt;date&gt; 2020-04-20, 2020-06-15, 2020-12-12, 2020-04-20, 2020-06-15, 2020-12-12, 2020-04-20, 2020-06-15,… ## $ mean &lt;dbl&gt; -0.2950616, -0.3615610, -0.4304080, -0.3466159, -0.3783803, -0.4410880, -0.1925701, -0.2555717, … ## $ se &lt;dbl&gt; 0.01440347, 0.01583371, 0.01736561, 0.01285579, 0.01680848, 0.01813122, 0.01381664, 0.01529698, … ## $ dv &lt;chr&gt; &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Poole… ## Rows: 12 ## Columns: 5 ## Groups: wavedate [3] ## $ wavedate &lt;date&gt; 2020-04-20, 2020-04-20, 2020-04-20, 2020-04-20, 2020-06-15, 2020-06-15, 2020-06-15, 2020-06-15,… ## $ dv &lt;chr&gt; &quot;level_democracy.z&quot;, &quot;proudcitizen.z&quot;, &quot;supp_demcy.z&quot;, &quot;system_satisfaction.z&quot;, &quot;level_democracy… ## $ mean &lt;dbl&gt; -0.49391135, -0.18197042, -0.26015389, -0.08754136, -0.55958182, -0.27035667, -0.26809312, -0.17… ## $ se &lt;dbl&gt; 0.01516400, 0.01477147, 0.01109283, 0.01313228, 0.01781351, 0.01725895, 0.01311345, 0.01501777, … ## $ country &lt;chr&gt; &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Poole… ## Rows: 3 ## Columns: 5 ## $ wavedate &lt;date&gt; 2020-04-20, 2020-06-15, 2020-12-12 ## $ mean &lt;dbl&gt; -0.2558943, -0.3181518, -0.3712863 ## $ se &lt;dbl&gt; 0.006884393, 0.008026691, 0.008694820 ## $ country &lt;chr&gt; &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot; ## $ dv &lt;chr&gt; &quot;Pooled&quot;, &quot;Pooled&quot;, &quot;Pooled&quot; ## # A tibble: 3 × 5 ## wavedate mean se country dv ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2020-04-20 -0.26 0.00688 Pooled Pooled ## 2 2020-06-15 -0.32 0.00803 Pooled Pooled ## 3 2020-12-12 -0.37 0.00869 Pooled Pooled Readibility After seeing this code my first impressions are: This code is a combination of various data wrangling and analysis steps, including custom functions to streamline the workflow for this project. These various step are needed to plot the various plots inside the code and article. The code is really well documented. It has a lot of comments indicating what is the function of each chunk code inside code. This make more easy to understand what does the code do. The name of each variable and object makes sense. They don’t have a random name, which makes easier to understand what is inside of object/list. Readibility score Thus, due to the previous points, I’ll be giving to this article a readibility score of 5 stars Reproducibility To rate the reproducibility of this article, I will try to reproduce the first plot in the R script “agg_plot.R”. I will try to reproduce the the next code: # ~ Draw system plot --------------------------------------------------------- # ~ Panel A of Figure 1 system_facet &lt;- ggplot(system_plotdata, aes( x = wavedate, y = mean, color = dv)) + geom_rect(data = filter(system_plotdata, country == &quot;Pooled&quot;), fill = NA, color = &quot;black&quot;, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf) + geom_hline(aes(yintercept = 0)) + geom_point(size = 1, alpha = .5) + geom_line(aes(group = dv), alpha = .7) + # add extra width to pooled lines geom_line(data = filter(system_plotdata,dv == &quot;Pooled&quot;), size = 1) + # add errorbars only to pooled estimates geom_errorbar(data = filter(system_plotdata,dv == &quot;Pooled&quot;), aes(ymin = mean - myquantile(95)*se, ymax = mean + myquantile(95)*se), size = .6, width = 0) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_color_manual(name = NULL, values = c(&quot;#000000&quot;, viridisLite::viridis(4)), labels = c(&quot;Pooled&quot;, &quot;\\nLevel of \\nDemocracy&quot;, &quot;Proud Citizen&quot;, &quot;\\nSupport for \\nDemocracy&quot;, &quot;\\nSatisf. with \\nPol. System&quot;) ) + scale_x_date(breaks = ymd(c(&quot;2020-04-20&quot;,&quot;2020-06-15&quot;,&quot;2020-12-12&quot;)), limits = ymd(c(&quot;2020-04-01&quot;, &quot;2020-12-31&quot;)), date_labels = &quot;%b&quot;) + ggtitle(&quot;System Support&quot;) + facet_grid(~country) + scale_y_continuous(limits = c(-1, .2)) + theme_minimal() + theme(panel.grid.minor = element_blank()) system_facet Issues The first issue that I encounter to reproduce this code had something to do with the importing of the data. # Import data ------------------------------------------------------------- df_full &lt;- readRDS(&quot;B-analysis-data/yougov_clean_202204122.rds&quot;) var_lookup &lt;- readRDS(&quot;B-analysis-data/varlookup.rds&quot;) There are two main issues with this code: The first one is a very common issue. Obviously the data/folder structure of the original project differs with my data/folder structure. For this reason the needed file cannot been found in my computer directory The second one has something to do with the name of the files. The file name yougov_clean_202204122.rds differs with the file name in the folder B-analysis-data. The file name in this folder yougov_clean_20211210.rds. We can resolve this issue modifing the previous code as follow: # Import data ------------------------------------------------------------- df_full &lt;- readRDS(here(&quot;projects&quot;, &quot;review&quot;, &quot;B-analysis-data&quot;, &quot;yougov_clean_20211210.rds&quot;)) var_lookup &lt;- readRDS(here(&quot;projects&quot;, &quot;review&quot;, &quot;B-analysis-data&quot;, &quot;varlookup.rds&quot;)) Plot After resolving this previous issues we can reproduce the next figure: # ~ Draw system plot --------------------------------------------------------- # ~ Panel A of Figure 1 system_facet &lt;- ggplot(system_plotdata, aes( x = wavedate, y = mean, color = dv)) + geom_rect(data = filter(system_plotdata, country == &quot;Pooled&quot;), fill = NA, color = &quot;black&quot;, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf) + geom_hline(aes(yintercept = 0)) + geom_point(size = 1, alpha = .5) + geom_line(aes(group = dv), alpha = .7) + # add extra width to pooled lines geom_line(data = filter(system_plotdata,dv == &quot;Pooled&quot;), size = 1) + # add errorbars only to pooled estimates geom_errorbar(data = filter(system_plotdata,dv == &quot;Pooled&quot;), aes(ymin = mean - myquantile(95)*se, ymax = mean + myquantile(95)*se), size = .6, width = 0) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_color_manual(name = NULL, values = c(&quot;#000000&quot;, viridisLite::viridis(4)), labels = c(&quot;Pooled&quot;, &quot;\\nLevel of \\nDemocracy&quot;, &quot;Proud Citizen&quot;, &quot;\\nSupport for \\nDemocracy&quot;, &quot;\\nSatisf. with \\nPol. System&quot;) ) + scale_x_date(breaks = ymd(c(&quot;2020-04-20&quot;,&quot;2020-06-15&quot;,&quot;2020-12-12&quot;)), limits = ymd(c(&quot;2020-04-01&quot;, &quot;2020-12-31&quot;)), date_labels = &quot;%b&quot;) + ggtitle(&quot;System Support&quot;) + facet_grid(~country) + scale_y_continuous(limits = c(-1, .2)) + theme_minimal() + theme(panel.grid.minor = element_blank()) system_facet Reproducibility score Thus, due to the previous points, I’ll be giving to this article a reproducibilityscore of 4.5 stars "],["relational-databases.html", "Relational databases Loading data", " Relational databases Loading data flu_df &lt;- read.csv(here::here(&quot;projects/relational_databases/data/flu_data_db.csv&quot;), header = TRUE) head(flu_df) ## Date Argentina Australia Austria Belgium Bolivia Brazil Bulgaria Canada Chile France Germany Hungary Japan ## 1 2002-12-29 NA NA NA NA NA 174 NA NA NA NA NA NA NA ## 2 2003-01-05 NA NA NA NA NA 162 NA NA NA NA NA NA NA ## 3 2003-01-12 NA NA NA NA NA 174 NA NA 1 NA NA NA NA ## 4 2003-01-19 NA NA NA NA NA 162 NA NA 0 NA NA NA NA ## 5 2003-01-26 NA NA NA NA NA 131 NA NA 0 NA NA NA NA ## 6 2003-02-02 136 NA NA NA NA 151 NA NA 0 NA NA NA NA ## Mexico Netherlands New.Zealand Norway Paraguay Peru Poland Romania Russia South.Africa Spain Sweden Switzerland ## 1 NA NA NA NA NA 329 NA NA NA NA NA NA NA ## 2 NA NA NA NA NA 315 NA NA NA NA NA NA NA ## 3 NA NA NA NA NA 314 NA NA NA NA NA NA NA ## 4 NA NA NA NA NA 267 NA NA NA NA NA NA NA ## 5 NA NA NA NA NA 241 NA NA NA NA NA NA NA ## 6 NA NA NA NA NA 227 NA NA NA NA NA NA NA ## Ukraine United.States Uruguay ## 1 NA NA NA ## 2 NA NA NA ## 3 NA NA NA ## 4 NA NA NA ## 5 NA NA NA ## 6 NA NA NA dengue_df &lt;- read.csv(here::here(&quot;projects/relational_databases/data/dengue_data_db.csv&quot;), header = TRUE) head(dengue_df) ## Date Argentina Bolivia Brazil India Indonesia Mexico Philippines Singapore Thailand Venezuela ## 1 2002-12-29 NA 0.101 0.073 0.062 0.101 NA NA 0.059 NA NA ## 2 2003-01-05 NA 0.143 0.098 0.047 0.039 NA NA 0.059 NA NA ## 3 2003-01-12 NA 0.176 0.119 0.051 0.059 0.071 NA 0.238 NA NA ## 4 2003-01-19 NA 0.173 0.170 0.032 0.039 0.052 NA 0.175 NA NA ## 5 2003-01-26 NA 0.146 0.138 0.040 0.112 0.048 NA 0.164 NA NA ## 6 2003-02-02 NA 0.160 0.202 0.038 0.049 0.041 NA 0.163 NA NA gapminder_df &lt;- gapminder head(gapminder_df) ## country year infant_mortality life_expectancy fertility population gdp continent ## 1 Albania 1960 115.40 62.87 6.19 1636054 NA Europe ## 2 Algeria 1960 148.20 47.50 7.65 11124892 13828152297 Africa ## 3 Angola 1960 208.00 35.98 7.32 5270844 NA Africa ## 4 Antigua and Barbuda 1960 NA 62.97 4.43 54681 NA Americas ## 5 Argentina 1960 59.87 65.39 3.11 20619075 108322326649 Americas ## 6 Armenia 1960 NA 66.86 4.55 1867396 NA Asia ## region ## 1 Southern Europe ## 2 Northern Africa ## 3 Middle Africa ## 4 Caribbean ## 5 South America ## 6 Western Asia The flu and dengue dataframes are not tidy. Let’s make them tidy. # Making flu data tidy flu_tidy &lt;- flu_df %&gt;% pivot_longer(cols = c(&#39;Argentina&#39;:&#39;Uruguay&#39;), names_to = &quot;country&quot;, values_to = &quot;cases&quot;) flu_tidy &lt;- separate(flu_tidy, Date, into = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;)) knitr::kable(head(flu_tidy)) year month day country cases 2002 12 29 Argentina NA 2002 12 29 Australia NA 2002 12 29 Austria NA 2002 12 29 Belgium NA 2002 12 29 Bolivia NA 2002 12 29 Brazil 174 # Making dengue data tidy dengue_tidy &lt;- dengue_df %&gt;% pivot_longer(cols = c(&quot;Argentina&quot;:&quot;Venezuela&quot;), names_to = &quot;country&quot;, values_to = &quot;cases&quot;) dengue_tidy &lt;- separate(dengue_tidy, Date, into = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;)) knitr::kable(head(dengue_tidy)) year month day country cases 2002 12 29 Argentina NA 2002 12 29 Bolivia 0.101 2002 12 29 Brazil 0.073 2002 12 29 India 0.062 2002 12 29 Indonesia 0.101 2002 12 29 Mexico NA "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
